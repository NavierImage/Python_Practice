import sys
n, m = map(int, sys.stdin.readline().split())
chess = []
for i in range(n):
    t = sys.stdin.readline()
    chess.append(t)
result1 = []
for i in range(n - 7):
    for j in range(m - 7):
        cnt_w = 0
        cnt_b = 0
        for k in range(i, i + 8): 
            for w in range(j, j + 8):
                if (k + w) % 2 == 0:
                    if chess[k][w] == 'W':
                        cnt_b += 1
                    if chess[k][w] == 'B':
                        cnt_w += 1
                else:
                    if chess[k][w] == 'W':
                        cnt_w += 1
                    if chess[k][w] == 'B':
                        cnt_b += 1
 #체스판 분리는 하겠으나... 후에 분리를 못하겠었음... 
 #아무것도 바꿀 필요가 없는 경우엔... 둘다 32가됨.
 #완벽한 판일 경우, 한쪽이 64, 한쪽이 0이됨.
 #제일 최악의 판일 경우, 한쪽이 32 한쪽이 32가됨 
 #https://god-gil.tistory.com/m/62 이분의 풀이를 참고하였습니다.
 #https://www.acmicpc.net/problem/1018                    


        result1.append(cnt_b)
        result1.append(cnt_w)

print(min(result1))

'''import sys
n, m = map(int, sys.stdin.readline().split())
chess = []
for i in range(n):
    t = sys.stdin.readline()
    chess.append(t)
result = []
for i in range(n - 7):
    for j in range(m - 7):
        cnt = 0
        costco = 0
        for k in range(i, i + 8): 
            costco += 1
            det_i = i % 2
            det_j = j % 2
            for w in range(j, j + 8):
                if costco % 2 != 0:
                    if (chess[i][j] == chess[k][w]) and (det_j != (w % 2)):
                        cnt += 1
                    elif (det_j == (w % 2)) and (chess[i][j] != chess[k][w]):
                        cnt += 1
                    else:
                        pass
                else:
                    if (det_j == (w % 2)) and (chess[i][j] == chess[k][w]):
                        cnt += 1
                    elif (det_j != (w % 2)) and (chess[i][j] != chess[k][w]):
                        cnt += 1
                    else:
                        pass    
        result.append(cnt)
print(min(result))'''

#이건 내가 생각했던 코드지만, 반례가 존재함...
#시작점을 고정시켜버리니 반례가 존재
